# schemaStore.ts

**Location:** `/src/stores/schemaStore.ts`
**Type:** Zustand Store

## Purpose

The **heart of the application** - manages all database schema design data including models, enums, relationships, and their visual positions. This store is persisted to localStorage and synced with the backend.

## State Interface

```typescript
interface SchemaState {
  models: ModelWithUI[];              // Database models/tables
  enums: EnumWithUI[];                // Enum definitions
  associationTables: AssociationTable[];  // Many-to-many join tables

  // Model operations
  addModel: (model) => string;
  updateModel: (id, updates) => void;
  deleteModel: (id) => void;
  getModel: (id) => ModelWithUI | undefined;

  // Column operations (within models)
  addColumn: (modelId, column) => void;
  updateColumn: (modelId, columnName, updates) => void;
  deleteColumn: (modelId, columnName) => void;

  // Relationship operations (within models)
  addRelationship: (modelId, relationship) => void;
  updateRelationship: (modelId, relationshipName, updates) => void;
  deleteRelationship: (modelId, relationshipName) => void;

  // Enum operations
  addEnum: (enumDef, position?) => string;
  updateEnum: (id, updates) => void;
  deleteEnum: (id) => void;

  // Association table operations
  addAssociationTable: (table) => void;
  updateAssociationTable: (name, updates) => void;
  deleteAssociationTable: (name) => void;

  // Position updates (for React Flow)
  updateModelPosition: (id, position) => void;
  updateEnumPosition: (id, position) => void;

  // Bulk operations
  loadSchema: (models, enums, associationTables) => void;
  clearAll: () => void;
}
```

## Data Structures

### ModelWithUI
```typescript
{
  id: string;                    // UI-only, generated by nanoid()
  name: string;                  // e.g., "User"
  tablename?: string;            // e.g., "users" (defaults to snake_case of name)
  columns: Column[];             // Array of column definitions
  relationships?: Relationship[]; // OneToOne, OneToMany, ManyToMany
  position: { x: number, y: number };  // For React Flow canvas
}
```

### EnumWithUI
```typescript
{
  id: string;                    // UI-only, generated by nanoid()
  name: string;                  // e.g., "UserRole"
  values: string[];              // e.g., ["ADMIN", "USER", "GUEST"]
  position: { x: number, y: number };
}
```

### Column
```typescript
{
  name: string;                  // e.g., "email"
  type: ColumnTypeName;          // e.g., "String", "Integer", "Boolean"
  primary_key?: boolean;
  nullable?: boolean;
  unique?: boolean;
  index?: boolean;
  autoincrement?: boolean;
  default?: string | number | boolean;
  foreign_key?: {
    model: string;               // Referenced model name
    ondelete?: "CASCADE" | "SET NULL" | ...;
  };
}
```

### Relationship
```typescript
{
  name: string;                  // e.g., "posts" (relationship attribute name)
  type: "OneToOne" | "OneToMany" | "ManyToMany";
  target_model: string;          // e.g., "Post"
  back_populates?: string;       // e.g., "author" (reverse relationship name)
  foreign_key?: string;          // Column name (for OneToOne/OneToMany)
  association_table?: string;    // Join table name (for ManyToMany)
}
```

## Key Features

### 1. Automatic ID Generation
```typescript
addModel: (model) => {
  const id = nanoid();  // Generates unique ID like "V1StGXR8_Z5jdHi6B"
  const newModel: ModelWithUI = {
    ...model,
    id,
    position: model.position || { x: 100, y: 100 },
  };
  set((state) => ({
    models: [...state.models, newModel],
  }));
  return id;  // Return ID for immediate use
}
```

### 2. Immutable Updates
All updates use **immutable patterns** (spread operator):
```typescript
updateModel: (id, updates) => {
  set((state) => ({
    models: state.models.map((m) =>
      m.id === id ? { ...m, ...updates } : m
    ),
  }));
}
```

React detects changes and re-renders only affected components.

### 3. Nested CRUD Operations
Manage columns/relationships within models:
```typescript
addColumn: (modelId, column) => {
  set((state) => ({
    models: state.models.map((m) =>
      m.id === modelId
        ? { ...m, columns: [...m.columns, column] }
        : m
    ),
  }));
}
```

### 4. Position Tracking
Store x/y coordinates for React Flow canvas:
```typescript
updateModelPosition: (id, position) => {
  set((state) => ({
    models: state.models.map((m) =>
      m.id === id ? { ...m, position } : m
    ),
  }));
}
```

### 5. Persistence
```typescript
persist(
  (set, get) => ({ /* state */ }),
  {
    name: "schema-storage",  // localStorage key
  }
)
```

All changes automatically saved to `localStorage["schema-storage"]`.

## How It Fits Into The Application

### Creating a Model
```
User clicks "Add Model" in SchemaToolbar
  ↓
schemaStore.addModel({
  name: "User",
  columns: [
    { name: "id", type: "Integer", primary_key: true }
  ]
})
  ↓
Returns new model ID
  ↓
ModelNode appears on React Flow canvas
  ↓
flowConverter.ts converts model to React Flow node
```

### Editing a Model
```
User clicks ModelNode
  ↓
ModelEditor modal opens
  ↓
User changes name/tablename/columns
  ↓
Submit form
  ↓
schemaStore.updateModel(id, { name: "NewName" })
  ↓
React Flow re-renders with new data
```

### Adding a Relationship
```
User opens RelationshipEditor
  ↓
Selects: OneToMany from User to Post
  ↓
schemaStore.addRelationship("user-id", {
  name: "posts",
  type: "OneToMany",
  target_model: "Post",
  back_populates: "author"
})
  ↓
Edge appears on canvas (User → Post)
```

### Dragging a Node
```
User drags ModelNode on canvas
  ↓
React Flow onNodesChange event
  ↓
schemaStore.updateModelPosition(id, { x: 250, y: 150 })
  ↓
Position persisted to localStorage
```

### Loading a Project
```
User clicks project in ProjectsListPage
  ↓
schemas.getById(projectId) fetches from API
  ↓
Parse JSON spec into models/enums/associationTables
  ↓
schemaStore.loadSchema(models, enums, associationTables)
  ↓
Replaces entire store state
  ↓
Navigate to /schema-builder/:id
  ↓
Canvas renders loaded data
```

### Saving a Project
```
User clicks "Save" in SchemaToolbar
  ↓
buildFastAPIProjectSpec() reads from schemaStore
  ↓
Combines with configStore data
  ↓
schemas.update(projectId, spec) sends to API
  ↓
Backend persists to database
```

## Data Flow Diagram

```
┌─────────────────┐
│  SchemaBuilder  │ (Page)
└────────┬────────┘
         │
    ┌────▼─────┐
    │ Toolbar  │ → addModel(), addEnum()
    └────┬─────┘
         │
    ┌────▼────────┐
    │ React Flow  │
    │   Canvas    │
    └────┬────────┘
         │
    ┌────▼────────┐
    │  ModelNode  │ → Click to edit
    └────┬────────┘
         │
    ┌────▼──────────┐
    │  ModelEditor  │ → updateModel(), addColumn()
    └────┬──────────┘
         │
    ┌────▼──────────┐
    │ schemaStore   │ ← Single source of truth
    └────┬──────────┘
         │
    ┌────▼──────────┐
    │ localStorage  │ (persisted)
    └───────────────┘
```

## Usage Examples

### Create a User Model
```typescript
import { useSchemaStore } from '@/stores/schemaStore';

const addModel = useSchemaStore((state) => state.addModel);

const userId = addModel({
  name: "User",
  columns: [
    { name: "id", type: "Integer", primary_key: true, autoincrement: true },
    { name: "email", type: "String", unique: true, nullable: false },
    { name: "username", type: "String", nullable: false },
    { name: "created_at", type: "DateTime", default: "now()" },
  ],
  position: { x: 100, y: 100 },
});
```

### Add a Column
```typescript
const addColumn = useSchemaStore((state) => state.addColumn);

addColumn(userId, {
  name: "is_active",
  type: "Boolean",
  default: true,
});
```

### Create a Relationship
```typescript
const addRelationship = useSchemaStore((state) => state.addRelationship);

addRelationship(userId, {
  name: "posts",
  type: "OneToMany",
  target_model: "Post",
  back_populates: "author",
});
```

### Get All Models
```typescript
const models = useSchemaStore((state) => state.models);

console.log(models.length);  // 5
models.forEach(m => console.log(m.name));  // User, Post, Comment, ...
```

### Clear Everything
```typescript
const clearAll = useSchemaStore((state) => state.clearAll);
clearAll();  // Resets to { models: [], enums: [], associationTables: [] }
```

## Persistence Format

### localStorage Key
```
"schema-storage"
```

### Example Stored Data
```json
{
  "state": {
    "models": [
      {
        "id": "V1StGXR8_Z5jdHi",
        "name": "User",
        "tablename": "users",
        "columns": [
          {
            "name": "id",
            "type": "Integer",
            "primary_key": true,
            "autoincrement": true
          },
          {
            "name": "email",
            "type": "String",
            "unique": true
          }
        ],
        "relationships": [
          {
            "name": "posts",
            "type": "OneToMany",
            "target_model": "Post",
            "back_populates": "author"
          }
        ],
        "position": { "x": 100, "y": 100 }
      }
    ],
    "enums": [
      {
        "id": "X2AtBbR9_K3mwCv",
        "name": "UserRole",
        "values": ["ADMIN", "USER", "GUEST"],
        "position": { "x": 400, "y": 100 }
      }
    ],
    "associationTables": []
  },
  "version": 0
}
```

## Related Files
- [SchemaBuilder.tsx](../pages/SchemaBuilder.tsx.md): Main page using this store
- [ModelNode.tsx](../components/schema/nodes/ModelNode.tsx.md): Displays model data
- [ModelEditor.tsx](../components/schema/editors/ModelEditor.tsx.md): Updates models
- [flowConverter.ts](../lib/utils/flowConverter.ts.md): Converts to React Flow format
- [specBuilder.ts](../lib/serializers/specBuilder.ts.md): Reads this store to build spec
- [fastapiSpec.ts](../types/fastapiSpec.ts.md): Type definitions

## Performance Considerations

### Why Zustand?
- **Small bundle size**: ~1KB
- **Fast updates**: No unnecessary re-renders
- **Simple API**: Easy to understand and use
- **No boilerplate**: Unlike Redux

### Selector Optimization
```typescript
// ❌ Bad: Re-renders on any state change
const store = useSchemaStore();

// ✅ Good: Only re-renders when models change
const models = useSchemaStore((state) => state.models);

// ✅ Better: Only re-renders when specific model changes
const user = useSchemaStore(
  (state) => state.models.find(m => m.name === "User")
);
```

## Common Operations Cheatsheet

```typescript
// Add model
const id = addModel({ name: "User", columns: [...] });

// Update model
updateModel(id, { name: "UpdatedUser" });

// Delete model
deleteModel(id);

// Add column to model
addColumn(modelId, { name: "email", type: "String" });

// Update column
updateColumn(modelId, "email", { unique: true });

// Delete column
deleteColumn(modelId, "email");

// Add relationship
addRelationship(modelId, { name: "posts", type: "OneToMany", ... });

// Update node position
updateModelPosition(id, { x: 200, y: 300 });

// Load from API
loadSchema(models, enums, associationTables);

// Clear everything
clearAll();
```

## Debugging

### View store in console
```javascript
// In browser console
JSON.parse(localStorage.getItem('schema-storage'))
```

### Check model count
```javascript
useSchemaStore.getState().models.length
```

### Find model by name
```javascript
useSchemaStore.getState().models.find(m => m.name === "User")
```

### Clear store
```javascript
useSchemaStore.getState().clearAll()
localStorage.removeItem('schema-storage')
```
